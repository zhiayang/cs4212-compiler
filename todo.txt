TODO

1. all the other statement and expression types
	- readln
	- conditional branch (on relops and consts)
	- dotop assigns


3. insert pseudo-ops for GetElementPtr and StoreField so we can safely perform dotop assigns.
	as it stands now, if we have `a.x = p + q`, and a, p, and q are all spilled, then we
	simply do not have enough scratch registers to deal with this.

	if we split it up into 2 operations, then we solve this problem since we only need 2
	scratch registers.



4. find some way to tell the register allocator about caller-saved registers
	- ideally we want some way to automatically spill a1-a4 across a function call
	- maybe by having calls "def" a1-a4, but those are registers and not variables...

5. string concat

6. long division

7. make spilled bools 1 byte instead of 4

8. locals should be cleared to 0 i guess.


11. see if we need (want) to toposort the basic blocks before renumbering/allocating


12. ensure stack alignment on function calls



16. in ir3, don't generate short-circuiting code if the potentially-elided operand has no side effects.
	-- no need to short circuit:
	foo   || bar
	foo() || bar

	-- must short circuit:
	foo   || bar()
	foo() || bar()

	(same applies for &&)



17. register allocation coalescing


18. ir3 for string concat should return a different operator (not '+', maybe 's+'?)



19. see if it's possible to "properly split" the live ranges. right now, even though there might be disjoint parts in a var's
	live range, the var must still use the same register (or spill) throughout.

	if possible, split it up, so that we can (eg.) perform partial spills, and/or use a different register for different
	subranges of the live range.



20. peephole optimisations.....








-- done
12. potentially preprocess ir3 (or just change it in ir3 itself...) so that we:
	- always make temporaries for strings, since they need a register. this way the register allocator can
	  give them a register "normally", without relying on scratch. this would depend on (13)

	- make temporaries for nums outside of [-128, 127] or [0, 255] (same reason).

	these depend on (13) -- more intelligent scratch allocation. or rather, they are mutually dependent. if
	we don't have scratch registers, then we must have a register allocated for strings and numbers. if we
	don't have registers allocated, then we must have scratch.



-- for now, we only consider IN.
11. investigate whether the live range of a def should consider statements where the def only
	appears in OUT, and not in IN.



-- for now, we decided to just modify the caller stack.
8. investigate whether the spilling "backup" is required. arm specs say:
	"A callee can modify any stack space used for receiving parameter values from the caller."
	Procedure Call Standard for the Arm Architecture, Release 2020Q2 (page 24)
